
#pragma once


class ASTParser
{
public:
	int testfunc(int, float, double);
	class ASTPosition
	{
	public:
		ASTPosition& operator = (const ASTPosition& o) { this->Position = o.Position; return *this; }
		operator int() { return Position; }

		Token& GetToken();
		Token& GetNextToken();

		ASTPosition(ASTParser& parser);
		
		static bool FilterWhitespaceComments(Token& token) { if (token.TokenType == Token::Type::Newline || token.TokenType == Token::Type::Whitespace || token.TokenType == Token::Type::CommentMultiLine || token.TokenType == Token::Type::CommentSingleLine) return false; return true; }
		static bool FilterComments(Token& token) { if (token.TokenType == Token::Type::CommentMultiLine || token.TokenType == Token::Type::CommentSingleLine) return false; return true; }
		static bool FilterNone(Token& token) { return true; }

		void Increment(int count=1, bool (*filterAllows)(Token& token)=&FilterWhitespaceComments);
		
		ASTParser& Parser;
		int Position;
	};
	ASTParser() {}
	ASTParser(Tokenizer& fromTokenizer);
	std::vector<Token> Tokens;
	
	bool Parse(ASTNode* parent, ASTPosition& position);
protected:

	
	bool ParseRoot(ASTNode* parent, ASTPosition& position);
	
	bool ParseEnum(ASTNode* parent, ASTPosition& position);
	bool ParseEnumDefinition(ASTNode* parent, ASTPosition& position);
	bool ParseClass(ASTNode* parent, ASTPosition& position);
	bool ParseClassInheritance(int &inheritancePublicPrivateProtected, ASTNode* parent, ASTPosition& position);
	bool ParsePublicPrivateProtected(int& privatePublicProtected, ASTNode* parent, ASTPosition& cposition );
	bool ParseFunction(int privatePublicProtected, ASTNode* parent, ASTPosition& cposition);
	bool ParseFunctionArgument(ASTNode* parent, ASTPosition& cposition);
	bool ParseConstructorInitializer(ASTNode* parent, ASTPosition& cposition);
	bool ParseVariables(int privatePublicProtected, ASTNode* parent, ASTPosition& cposition );
	bool ParsePartialVariable( ASTNode& subNode, ASTPosition &position, int privatePublicProtected, std::vector<Token>& modifierTokens, std::vector<Token>& typeTokens );
	bool ParseType( ASTPosition &position, std::vector<Token> &typeTokens, std::vector<Token> &modifierTokens );
	bool ParsePointerReferenceSymbol(ASTPosition &position, std::vector<Token> &pointerTokens, std::vector<Token> &pointerModifierTokens );
	bool ParseSpecificScopeInner(ASTPosition& cposition, std::vector<Token> &insideBracketTokens, Token::Type tokenTypeL, Token::Type tokenTypeR, bool(*filterAllows)(Token& token) = &ASTParser::ASTPosition::FilterWhitespaceComments);

	

	bool ParseUnknown(ASTNode* parent, ASTPosition& position);
	bool ParseIgnored(ASTNode* parent, ASTPosition& position);
	bool ParseEndOfStream(ASTNode* parent, ASTPosition& position);
	


};


class ASTType
{
	std::vector<Token> typeModifiers;
	Token typeKeyword;
};

class ASTNode
{
public:
	ASTNode() { }
	~ASTNode() { DestroyChildren(); }

	void DestroyChildren() { for(auto it : children) { it->DestroyChildren(); delete it; } children.clear(); }
	void DestroyChildrenAndSelf() { DestroyChildren(); delete this; }

	std::string type;
	std::vector<ASTNode*> children;
	std::vector<std::string> data;
};

#include <string>

class Token
{
public:
	enum class Type
	{
		Init, // init state
		Whitespace, // <space>|<tab>
		Newline, // \r|\n|\r\n
		CommentSingleLine,
		CommentMultiLine,
		LBracket, // [
		RBracket, // ]
		LBrace, // {
		RBrace, // }
		LParen, // (
		RParen, // )
		Dot, // .
		Comma, // ,
		Doublecolon, // ::
		Colon, // :
		Semicolon, // ;
		Exclamation, // !
		Equals, // =
		Ampersand, // &
		Asterisk, // *
		Keyword, // [a-zA-Z][a-zA-Z0-9_-]*
		Number, // [0-9][.0-9]*
		Class, // class
		Enum, // enum
		Public, // public
		Private, // private
		Protected, // protected
		Unsigned, // unsigned
		Undefined, // undefined
		Allocate, // allocate
		String,
		CharConstant,
		Const, // const
		Null, // null
		BuiltinType, // int64|int|short|char|long|double|float|bool
		Unknown, // <everything else>
		EndOfStream, // 0 bytes remaining
	};
	Token(): TokenType(Type::Init) {}

	Type TokenType;
	std::string TokenData;
	std::string TokenParsedData;
	int TokenByteOffset;
};

class Tokenizer
{
public:
	Token GetNextToken();			
protected:
	Tokenizer(): m_offset(0) {}

	virtual std::string PeekBytes(int numBytes, int offset=0)=0;
	virtual int Advance(int numBytes)=0;

	Token PeekNextToken(int& offset);

	int AddPart( Token &token, std::string &next, int& offset );

	int IsCombinableWith(Token& tok, Token& nextToken);
	void ConvertToSpecializedKeyword(Token& tokKeyword);
	int m_offset;
};

class StringTokenizer: public Tokenizer
{
public:
	StringTokenizer(std::string data) { Source = data; }
protected:
	virtual std::string PeekBytes( int numBytes, int offset=0 );
	virtual int Advance( int numBytes );

	std::string Source;
};

#pragma once

#include <vector>
#include "tokenizer.h"
